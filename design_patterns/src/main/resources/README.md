
### 原型模式
指原型实例指定创建对象的种类，并且通过复制这些原创创建新的对象。
原型模式的使用场景
    类初始化消耗资源较多
    使用new生成一个对象需要非常烦琐的过程（数据准备、访问权限等）
    构造函数比较复杂
    在循环体中产生大量对象
如果我们克隆的目标对象是单例对象，那么意味着深克隆会破坏单例模式，实际上防止克隆破坏单例模式的解决思路非常简单，禁止深克隆即可
    单例类不实现Cloneable接口
    重写clone方法，在clone方法中返回单例对象即可
    
    
### 代理模式
代理模式的定义非常简单，是指为其他对象提供一种代理，以控制对这个对象的访问。代理对象在客户端和目标对象之间起到中介作用，代理模式属于结构型设计模式。
使用代理模式有两个目的：
    保护目标对象
    增强目标对象
jdk代理 & cglib代理 区别：
    （1）cglib执行方法比jdk效率高，因为cglib采用了fastClass机制，
        cglib的原理简单来说就是：为代理类和被代理类各生成一个类，这个类会为代理类和被代理类的方法分配一个index(int类型)；
        这个index当作一个入参，fastClass就可以直接定位到要调用的方法并直接进行调用，省去了反射调用，
        所以调用效率比jdk代理通过反射调用高。
    （2）jdk动态代理实现了被代理对象的接口，cglib代理继承了被代理对象
    （3）jdk代理和cglib代理都在运行期生成字节码，jdk直接写class字节码，cglib代理使用ASM框架写class字节码，cglib代理实现更复杂，生成代理类比jdk动态代理效率低
    （4）jdk动态代理调用代理方法是通过反射机制调用，cglib代理是通过fastClass机制直接调用方法的，cglib代理执行效率更高
静态代理和动态代理本质区别：
    （1）静态代理只能通过手动完成代理操作，如果被代理类增加类新的方法，代理类需要同步增加，违反开闭原则
    （2）动态代理采用在运行时动态生成代码的方式，取消了对被代理类的拓展限制，遵循开闭原则
    （3）若动态代理要对目标类的增强逻辑进行拓展，结合策略模式，只需要新增策略类便可完成，无须修改代理类的代码
代理模式的优缺点：
    优点：
        （1）代理模式能将对立对象和真是被调用对象分离
        （2）在一定程度上降低类系统的耦合性，拓展性好
        （3）可以起到保护目标对象的作用
        （4）可以增强目标对象的功能
    缺点：
        （1）代理模式会造成系统设计中类的数量增加
        （2）在客户端和目标对象中增加一个代理对象，会导致请求处理速度变慢
        （3）增加了系统的复杂度
### 委派模式
委派模式的基本作用就是负责任务的调用和分配，根代理模式很像，可以看作一种特殊情况下的静态的全权代理，但是代理模式注重过程，而委派模式注重结果。
    
### 策略模式
指定义了算法家族并分别封装起来，让它们之间可以互相替换，此模式使得算法的变化不会影响使用算法的用户。
应用场景：
    （1）系统中有很多类，而它们的区别仅仅在于行为的不同
    （2）一个系统需要动态地在几个算法中选择一种
一个常见的应用场景，支付时会提示选择支付方式，如用户未选择，系统会使用默认的支付方式进行结算
优缺点：
    优点：
        （1）策略模式符合开闭原则
        （2）策略模式可以避免使用多重条件语句，如if...else语句、switch语句
        （3）使用策略模式可以提高算法的保密性和安全性
    缺点：
        （1）客户端必须知道所有的策略，并且自行决定使用哪一个策略模式
        （2）代码中产生非常多的策略类，增加了代码的维护难度
### 模板模式
指定义一个算法的骨架，并允许子类为一个或者多个步骤提供实现。模版模式使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤，属于行为型设计模式。
试用场景：
    （1）一次性实现一个算法的不变部分，并将可变的行为留给子类来实现
    （2）各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复
